# STL 丐版实现

## list

```cpp
#include <assert.h>

template <typename type>
class List;

template <typename type>
class _aNode;

template <typename type>
class _iterator;

// class Node
template <typename type>
class _aNode {
 private:
  template <typename type>
  friend class _iterator;
  template <typename type>
  friend class List;

  // fields
  _aNode* prev;
  _aNode* next;
  type* val;

  // constructor
  _aNode(type& val) {
    this->prev = nullptr;
    this->next = nullptr;
    this->val = val;
  }
  _aNode(_aNode* prev, _aNode* next, type& val) {
    this->prev = prev;
    this->next = next;
    this->val = new type(val);
  }
  _aNode(_aNode* prev, _aNode* next, type&& val) {
    this->prev = prev;
    this->next = next;
    this->val = new type(val);
  }
  _aNode(_aNode* prev, _aNode* next, type* val) {
    this->prev = prev;
    this->next = next;
    this->val = val;
  }
  ~_aNode() {
    if (val) {
      delete this->val;
    }
  }
};

// class iterator
template <typename type>
class _iterator {
  template <typename type>
  friend class _aNode;
  template <typename type>
  friend class List;

  using Node = _aNode<type>;
  using List = List<type>;

 private:
  Node* _currNode;
  List& _list;
  _iterator next() {}
  _iterator prev() {}
  Node* getNodeptr() { return this->_currNode; }

 public:
  // constructor
  _iterator(Node* node, List& l) : _currNode(node), _list(l) {}

  _iterator() { this->_currNode = nullptr; }

  _iterator(const _iterator& it) : _currNode(it._currNode), _list(it._list) {}

  // operator
  // ++--
  _iterator& operator++() {
    this->_currNode = this->_currNode->next;
    return *this;
  }
  _iterator& operator--() {
    this->_currNode = this->_currNode->prev;
    return *this;
  }

  _iterator operator++(int) {
    this->_currNode = this->_currNode->next;
    return _iterator(this->_currNode->prev, this->_list);
  }
  _iterator operator--(int) {
    this->_currNode = this->_currNode->prev;
    return _iterator(this->_currNode->next, this->_list);
  }

  // logic < <= > >= == !=

  // bool operator<(_iterator& right) { return this->_currNode <
  // right._currNode; } bool operator<(_iterator&& right) {
  //  return this->_currNode < right._currNode;
  //}

  // bool operator<=(_iterator& right) {
  //  return this->_currNode <= right._currNode;
  //}
  // bool operator<=(_iterator&& right) {
  //  return this->_currNode <= right._currNode;
  //}

  // bool operator>(_iterator& right) { return this->_currNode >
  // right._currNode; } bool operator>(_iterator&& right) {
  //  return this->_currNode > right._currNode;
  //}

  // bool operator>=(_iterator& right) {
  //  return this->_currNode >= right._currNode;
  //}
  // bool operator>=(_iterator&& right) {
  //  return this->_currNode >= right._currNode;
  //}

  bool operator==(_iterator& right) {
    return this->_currNode == right._currNode;
  }
  bool operator==(_iterator&& right) {
    return this->_currNode == right._currNode;
  }

  bool operator!=(_iterator& right) {
    return this->_currNode != right._currNode;
  }
  bool operator!=(_iterator&& right) {
    return this->_currNode != right._currNode;
  }

  // randomAccess + -
  _iterator operator-(int right) {
    Node* nodeptr = this->_currNode;
    while (right--) {
      if (nodeptr == this->_list._headptr) {
        ++right;
        nodeptr = nodeptr->prev;
        continue;
      }
      nodeptr = nodeptr->prev;
    }
    if (nodeptr == this->_list._headptr) {
      nodeptr = nodeptr->prev;
    }
    return _iterator(nodeptr, this->_list);
  }

  _iterator operator+(int right) {
    Node* nodeptr = this->_currNode;
    while (right--) {
      if (nodeptr == this->_list._headptr) {
        ++right;
        nodeptr = nodeptr->next;
        continue;
      }
      nodeptr = nodeptr->next;
    }
    if (nodeptr == this->_list._headptr) {
      nodeptr = nodeptr->next;
    }
    return _iterator(nodeptr, this->_list);
  }

  // val * ->
  type& operator*() { return *this->_currNode->val; }
  type* operator->() { return this->_currNode->val; }
};

// class List
template <typename type>
class List {
 public:
  template <typename type>
  friend class _aNode;
  template <typename type>
  friend class _iterator;

  using iterator = _iterator<type>;
  using Node = _aNode<type>;

 private:
  // fields
  Node* _headptr;
  long _size;

  // private method
  Node* addNode(Node* prev, Node* next, type& val) {
    Node* newNode = new Node(prev, next, val);
    return newNode;
  }

  Node* addNode(Node* prev, Node* next, type&& val) {
    Node* newNode = new Node(prev, next, val);
    return newNode;
  }

  Node* addNode(Node* prev, Node* next, type* val) {
    Node* newNode = new Node(prev, next, val);
    return newNode;
  }

  long addSize() { return ++this->_size; }
  long resize(long size) { return this->_size = size; }
  long reduceSize() { return --this->_size; }

 public:
  // constructor
  List() {
    // head pointer
    this->_headptr = addNode(this->_headptr, this->_headptr, nullptr);
    this->_headptr->prev = this->_headptr->next = this->_headptr;
    this->_size = 0;
  }
  ~List() {
    Node* nodeptr = this->_headptr->next;
    delete this->_headptr;
    while (nodeptr != this->_headptr) {
      Node* next = nodeptr->next;
      delete nodeptr;
      nodeptr = next;
    }
  }

  // isEmpty
  bool empty() { return this->_headptr == this->_headptr; }

  // get size
  long size() { return this->_size; }

  // get front
  type& front() { return this->_headptr->next->val; }

  // get back
  type& back() { return this->_headptr->prev->val; }

  // get iterator
  iterator begin() {
    // assert is !empty
    assert(this->_headptr->next != this->_headptr);
    return iterator(this->_headptr->next, *this);
  }

  iterator end() { return iterator(this->_headptr, *this); }

  // push
  type& push_back(type& val) {
    Node* newNode = this->addNode(this->_headptr->prev, this->_headptr, val);
    // point to new node
    this->_headptr->prev->next = newNode;
    this->_headptr->prev = newNode;
    // size++
    this->addSize();
    return this->_headptr->prev->val;
  }
  type& push_back(type&& val) {
    Node* newNode = this->addNode(this->_headptr->prev, this->_headptr, val);
    // point to new node
    this->_headptr->prev->next = newNode;
    this->_headptr->prev = newNode;
    // size++
    this->addSize();
    return *this->_headptr->prev->val;
  }

  type& push_front(type& val) {
    Node* newNode = this->addNode(this->_headptr, this->_headptr->next, val);
    // point to new node
    this->_headptr->next->prev = newNode;
    this->_headptr->next = newNode;
    // sizs++
    this->addSize();
    return *this->_headptr->next->val;
  }
  type& push_frount(type&& val) {
    Node* newNode = this->addNode(this->_headptr, this->_headptr->next, val);
    // point to new node
    this->_headptr->next->prev = newNode;
    this->_headptr->next = newNode;
    // sizs++
    this->addSize();
    return *this->_headptr->next->val;
  }

  // pop
  type pop_back() {
    Node* nodeptr = this->_headptr->prev;

    assert(nodeptr->next);
    // prev and next pointers change the direction
    nodeptr->prev->next = nodeptr->next;
    nodeptr->next->prev = nodeptr->prev;

    type returnVal = *nodeptr->val;

    // free
    delete nodeptr;
    // size--
    this->reduceSize();
    return returnVal;
  }

  type pop_front() {
    Node* nodeptr = this->_headptr->next;

    assert(nodeptr->next);
    // prev and next pointers change the direction
    nodeptr->prev->next = nodeptr->next;
    nodeptr->next->prev = nodeptr->prev;

    type returnVal = *nodeptr->val;

    // free
    delete nodeptr;
    // size--
    this->reduceSize();
    return returnVal;
  }

  // insert(Ç°²å)
  type& insert(long position, type& val) {
    // assert ! out of range
    assert(position >= 0 && position <= this->size - 1);

    // search
    Node* nodeptr = this->_headptr->next;
    while (position--) {
      nodeptr = nodeptr->next;
    }

    Node* newNode = addNode(nodeptr->prev, nodeptr, val);
    // point to new node
    nodeptr->prev->next = newNode;
    nodeptr->prev = newNode;
    // size++
    this->addSize();
    return *this->_headptr->prev->val;
  }

  type& insert(long position, type&& val) {
    // assert ! out of range
    assert(position >= 0 && position <= this->_size - 1);

    // search
    Node* nodeptr = this->_headptr->next;
    while (position--) {
      nodeptr = nodeptr->next;
    }

    Node* newNode = addNode(nodeptr->prev, nodeptr, val);
    // point to new node
    nodeptr->prev->next = newNode;
    nodeptr->prev = newNode;
    // size++
    this->addSize();
    return *this->_headptr->prev->val;
  }

  type& insert(iterator& it, type& val) {
    Node* nodeptr = it.getNodeptr();
    Node* newNode = addNode(nodeptr->prev, nodeptr, val);
    // point to new node
    nodeptr->prev->next = newNode;
    nodeptr->prev = newNode;
    // size++
    this->addSize();
    return *this->_headptr->prev->val;
  }

  type& insert(iterator& it, type&& val) {
    Node* nodeptr = it.getNodeptr();
    Node* newNode = addNode(nodeptr->prev, nodeptr, val);
    // point to new node
    nodeptr->prev->next = newNode;
    nodeptr->prev = newNode;
    // size++
    this->addSize();
    return *this->_headptr->prev->val;
  }

  // erase
  iterator erase(long position) {
    // assert ! out of range
    assert(position >= 0 && position <= this->size - 1);

    // search
    Node* nodeptr = this->_headptr->next;
    while (position--) {
      nodeptr = nodeptr->next;
    }

    assert(nodeptr->next);
    // prev and next pointers change the direction
    nodeptr->prev->next = nodeptr->next;
    nodeptr->next->prev = nodeptr->prev;

    iterator returnVal = iterator(nodeptr->next, *this);
    // free
    delete nodeptr;
    // size--
    this->reduceSize();
    return returnVal;
  }

  iterator erase(iterator& it) {
    // search
    Node* nodeptr = it.getNodeptr();

    assert(nodeptr->next);
    // prev and next pointers change the direction
    nodeptr->prev->next = nodeptr->next;
    nodeptr->next->prev = nodeptr->prev;

    iterator returnVal = iterator(nodeptr->next, *this);
    // free
    delete nodeptr;
    // size--
    this->reduceSize();
    return returnVal;
  }

  // clear
  void clear() {
    Node* nodeptr = this->_headptr->next;
    while (nodeptr != this->_headptr) {
      Node* next = nodeptr->next;
      delete nodeptr;
      nodeptr = next;
    }
    this->_headptr->next = this->_headptr->prev = this->_headptr;
    this->resize(0);
  }

  // find
  // TODO:
  //iterator find(type& val) {}
  //iterator find(type& val, long start) { assert(position + 1 <= this->_size); }
  //iterator find(type& val, iterator start) {
  //  assert(position + 1 <= this->_size);
  //}

  // operator []
  type& operator[](long index) {
    assert(this->_size > 0);
    long realIndex =
        index < 0 ? (this->_size - (-index % (this->_size))) % this->_size
                  : index % this->_size;
    Node* nodeptr = this->_headptr->next;
    while (realIndex--) {
      nodeptr = nodeptr->next;
    }
    assert(nodeptr->val);
    return *nodeptr->val;
  }
};

```

